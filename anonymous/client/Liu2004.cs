using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Security;
using System.Security.Cryptography;
using System.Text;

namespace LSAG
{
  // This scheme is described in "Linkable Spontaneous Anonymous Group Signature for Ad Hoc Groups"
  // by Joseph K. Liu, Victor K. Wei, and Duncan S. Wong - Information Security and Privacy, 2004

  public interface ILinkableSignature
  {
    /// <summary>
    /// Checks whether two signatures were generated by the same signer
    /// </summary>
    bool IsLinked(ILinkableSignature other);
  }

  public abstract class LiuScheme<SignType> where SignType : ILinkableSignature
  {
    static readonly byte[] hash1String = Encoding.UTF8.GetBytes("~~~Hash one");
    static readonly byte[] hash2String = Encoding.UTF8.GetBytes("+++Hash two");

    protected GroupParameters groupParameters = KnownGroupParameters.RFC5114_2_3_256;
    protected RandomNumberGenerator rng = new RNGCryptoServiceProvider();
    protected HMACDRBG drbg = new HMACDRBG();
    protected Modular mod;

    protected LiuScheme()
    {
      mod = new Modular(groupParameters.Prime);
    }

    public GroupParameters GroupParameters
    {
      get { return groupParameters; }
      set 
      {
        groupParameters = value;
        mod = new Modular(groupParameters.Prime);
      }
    }

    /// <summary>
    /// I'm not 100% sure that this is the best way to get this hash
    /// </summary>
    protected BigInteger Hash2(byte[] data)
    {
      drbg.Reseed(data, hash2String);
      var x = drbg.GenerateInteger(groupParameters.SubgroupSize);
      return mod.Pow(groupParameters.Generator, x);
    }

    protected BigInteger Hash1(byte[] data)
    {
      drbg.Reseed(data, hash1String);
      return drbg.GenerateInteger(groupParameters.SubgroupSize);
    }

    public abstract SignType GenerateSignature(byte[] message, BigInteger[] publicKeys, BigInteger privateKey, int identity);
    public abstract bool VerifySignature(byte[] message, BigInteger[] publicKeys, SignType signature);

    /// <summary>
    /// This is a cached version of the verifier, designed for mass verification of signatures coming from the same list of keys.
    /// If you keep the cache, subsequent verifications will be faster. This only matters when the number of keys is high (>50).
    /// </summary>
    /// <param name="message">The message which was signed</param>
    /// <param name="signature">The signature</param>
    /// <param name="keyCache">The cache, containing the list of public keys for which the signature was generated</param>
    /// <returns></returns>
    public abstract bool VerifySignature(byte[] message, SignType signature, MultiExponentiation keyCache);

    /// <summary>
    /// The key pairs are compatible with DSA
    /// </summary>
    /// <returns>A new key pair: { private, public }</returns>
    public BigInteger[] GenerateKeyPair()
    {
      var priv = rng.GenerateInteger(groupParameters.SubgroupSize);
      var pub = mod.Pow(groupParameters.Generator, priv);
      return new[] { priv, pub };
    }

    protected byte[] ConcatInts(byte[] prefix = null, params BigInteger[] ints)
    {
      var L = new List<byte>();
      if (prefix != null)
        L.AddRange(prefix);

      foreach (var key in ints)
        L.AddRange(key.ToByteArray());

      return L.ToArray();
    }
  }

  public class Liu2004 : LiuScheme<Liu2004.Signature>
  {
    public struct Signature : ILinkableSignature
    {
      public readonly BigInteger C1, Ytilda;
      public readonly BigInteger[] S;

      public Signature(BigInteger C1, BigInteger[] S, BigInteger Ytilda)
      {
        this.C1 = C1;
        this.S = S;
        this.Ytilda = Ytilda;
      }

      public bool IsLinked(ILinkableSignature s)
      {
        return Ytilda.Equals(((Signature)s).Ytilda);
      }
    }

    override public Signature GenerateSignature(byte[] message, BigInteger[] publicKeys, BigInteger privateKey, int identity)
    {
      var L = ConcatInts(null, publicKeys);
      var h = Hash2(L);
      var yTilda = mod.Pow(h, privateKey);

      var u = rng.GenerateInteger(GroupParameters.SubgroupSize);
      var prefix = ConcatInts(L, yTilda).Concat(message);
      var c = new BigInteger[publicKeys.Length];
      c[(identity + 1) % publicKeys.Length] =
        Hash1(ConcatInts(prefix, mod.Pow(GroupParameters.Generator, u), mod.Pow(h, u)));

      var s = new BigInteger[publicKeys.Length];
      for (int i = (identity + 1) % publicKeys.Length; i != identity;
        i = (i + 1) % publicKeys.Length)
      {
        s[i] = rng.GenerateInteger(GroupParameters.SubgroupSize);
        c[(i + 1) % publicKeys.Length] = Hash1(ConcatInts(prefix,
          (mod.Pow(GroupParameters.Generator, s[i]) * mod.Pow(publicKeys[i], c[i])).Mod(GroupParameters.Prime),
          (mod.Pow(h, s[i]) * mod.Pow(yTilda, c[i])).Mod(GroupParameters.Prime)));
      }

      s[identity] = (u - privateKey * c[identity]).Mod(GroupParameters.SubgroupSize);

      return new Signature(c[0], s, yTilda);
    }

    override public bool VerifySignature(byte[] message, BigInteger[] publicKeys, Signature signature)
    {
      var L = ConcatInts(null, publicKeys);
      var h = Hash2(L);

      var prefix = ConcatInts(L, signature.Ytilda).Concat(message);
      var c = signature.C1;
      BigInteger zDash, z2Dash;
      for (int i = 0; i < publicKeys.Length; ++i)
      {
        zDash = (mod.Pow(GroupParameters.Generator, signature.S[i]) * mod.Pow(publicKeys[i], c)).Mod(GroupParameters.Prime);
        z2Dash = (mod.Pow(h, signature.S[i]) * mod.Pow(signature.Ytilda, c)).Mod(GroupParameters.Prime);
        c = Hash1(ConcatInts(prefix, zDash, z2Dash));
      }

      return signature.C1.Equals(c);
    }

    public override bool VerifySignature(byte[] message, Liu2004.Signature signature, MultiExponentiation keyCache)
    {
      return VerifySignature(message, keyCache.Bases, signature);
    }
  }
}
